rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- HELPER FUNCTIONS ---

    // Check if the user is the owner (uses existing resource data)
    function isResourceOwner() {
      return request.auth.uid == resource.data.ownerId;
    }

    // Check if the user is the owner (uses new incoming data)
    function isRequestOwner() {
      return request.auth.uid == request.resource.data.ownerId;
    }

    // Check if the user is the creator of an organization
    function isOrganizationCreator(orgId) {
      return exists(/databases/$(database)/documents/organizations/$(orgId)) &&
             get(/databases/$(database)/documents/organizations/$(orgId)).data.createdBy == request.auth.uid;
    }

    // Check if user is in the 'participants' subcollection of an event
    function isParticipant(eventId) {
      return exists(/databases/$(database)/documents/events/$(eventId)/participants/$(request.auth.uid));
    }

    // Check if user is in the 'invitations' subcollection of an event
    function isInvited(eventId) {
      return exists(/databases/$(database)/documents/events/$(eventId)/invitations/$(request.auth.uid));
    }

    // Check if user has joined an event (via users/{userId}/joinedEvents/{eventId})
    function hasJoinedEvent(eventId) {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)/joinedEvents/$(eventId));
    }

    // Check if user is friend with the story creator
    function isFriendOfStoryCreator(storyCreatorId) {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)/friends/$(storyCreatorId));
    }

    // --- ORGANIZATIONS COLLECTION ---
    
    match /organizations/{orgId} {
      // Allow anyone authenticated to see the list of organizations
      allow get, list: if request.auth != null;

      // Allow creating an organization if:
      // 1. User is authenticated
      // 2. The 'createdBy' field matches the user's UID (Security check)
      allow create: if request.auth != null && 
                    request.resource.data.createdBy == request.auth.uid;

      // Allow updates and deletes only by the creator
      allow update, delete: if request.auth != null && 
                            resource.data.createdBy == request.auth.uid;

      // Subcollection: members (For the scalable architecture we discussed)
      match /members/{memberId} {
         allow read: if request.auth != null;
         
         // Allow users to join (add themselves) or the org creator to manage members
         allow write: if request.auth != null &&
                      (request.auth.uid == memberId || 
                       get(/databases/$(database)/documents/organizations/$(orgId)).data.createdBy == request.auth.uid);
      }
    }

    // --- EVENTS COLLECTION ---
    
    match /events/{eventId} {
      // Allow read access to:
      // - Public events (anyone authenticated)
      // - Private events if user is owner, participant, or invited
      allow get: if request.auth != null &&
                   (resource.data.type == "public" ||
                    isResourceOwner() ||
                    isParticipant(eventId) ||
                    isInvited(eventId));

      // Allow listing of all events for authenticated users
      // (filtering happens in the application layer)
      allow list: if request.auth != null;

      // Allow authenticated users to create events, ensuring the ownerId is their own UID
      // OR they are the creator of the organization specified as ownerId
      allow create: if request.auth != null &&
                       (isRequestOwner() ||
                        isOrganizationCreator(request.resource.data.ownerId));

      // Allow updates only by the event owner, and prevent changing ownership
      // OR by the organization creator if the event is owned by their organization
      allow update: if request.auth != null &&
                       (isResourceOwner() ||
                        isOrganizationCreator(resource.data.ownerId)) &&
                       (isRequestOwner() ||
                        isOrganizationCreator(request.resource.data.ownerId));

      // Allow deletes only by the event owner
      // OR by the organization creator if the event is owned by their organization
      allow delete: if request.auth != null &&
                       (isResourceOwner() ||
                        isOrganizationCreator(resource.data.ownerId));

      // Subcollection: participants
      match /participants/{userId} {
        allow get, list: if request.auth != null &&
                         (get(/databases/$(database)/documents/events/$(eventId)).data.type == "public" ||
                          get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                          isParticipant(eventId) ||
                          isInvited(eventId));

        allow create: if request.auth != null &&
                         request.auth.uid == userId &&
                         request.resource.data.uid == userId;

        allow delete: if request.auth != null &&
                         request.auth.uid == userId;
      }

      // Subcollection: invitations
      match /invitations/{userId} {
        allow get, list: if request.auth != null &&
                           (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                            request.auth.uid == userId);

        allow create: if request.auth != null &&
                         get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid;

        allow update: if request.auth != null &&
                         (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                          request.auth.uid == userId);

        allow delete: if request.auth != null &&
                         get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid;
      }

      // Subcollection: polls
      match /polls/{pollId} {
        // Allow read if user can read the parent event
        allow get, list: if request.auth != null &&
                           (get(/databases/$(database)/documents/events/$(eventId)).data.type == "public" ||
                            get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                            isParticipant(eventId) ||
                            isInvited(eventId));

        // Allow create/delete only for event owner
        allow create, delete: if request.auth != null &&
                                 get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid;

        // Allow update for event owner OR participants (for vote count increments)
        allow update: if request.auth != null &&
                         (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                          isParticipant(eventId));
        
        // Subcollection: votes
        match /votes/{userId} {
          // Allow read own vote or if user is event owner
          allow get: if request.auth != null &&
                       (userId == request.auth.uid ||
                        get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid);

          // Allow list only for event owner
          allow list: if request.auth != null &&
                         get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid;

          // Allow create own vote only if:
          // 1. User is authenticated
          // 2. Vote userId matches authenticated user (verified in both path and data)
          allow create: if request.auth != null &&
                          userId == request.auth.uid &&
                          request.resource.data.userId == request.auth.uid;

          // Prevent updates and deletes (votes are immutable)
          allow update, delete: if false;
        }
      }

      // Subcollection: messages (chat messages)
      match /messages/{messageId} {
        // Allow read if user is event owner, participant, or invited
        allow get, list: if request.auth != null &&
                           (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                            isParticipant(eventId) ||
                            isInvited(eventId));

        // Allow create only if:
        // 1. User is authenticated
        // 2. User is event owner, participant, or invited
        // 3. Message senderId matches authenticated user
        allow create: if request.auth != null &&
                         (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                          isParticipant(eventId) ||
                          isInvited(eventId)) &&
                         request.resource.data.senderId == request.auth.uid;

        // Prevent updates and deletes (messages are immutable)
        allow update, delete: if false;
      }

      // Subcollection: typing (typing status)
      match /typing/{userId} {
        // Allow read if user is event owner, participant, or invited
        allow get, list: if request.auth != null &&
                           (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                            isParticipant(eventId) ||
                            isInvited(eventId));

        // Allow create/update only for own typing status if user is owner, participant, or invited
        allow create, update: if request.auth != null &&
                                 request.auth.uid == userId &&
                                 (get(/databases/$(database)/documents/events/$(eventId)).data.ownerId == request.auth.uid ||
                                  isParticipant(eventId) ||
                                  isInvited(eventId));

        // Allow delete of own typing status
        allow delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // --- USERS COLLECTION ---
    
    match /users/{userId} {
      // Allow users to read their own profile and other users' profiles
      allow get, list: if request.auth != null;

      // Allow users to create/update/delete only their own profile
      allow create, update, delete: if request.auth != null && request.auth.uid == userId;

      // Subcollection: friends
      match /friends/{friendId} {
        allow get, list: if request.auth != null;
        allow create, delete: if request.auth != null &&
                                 (request.auth.uid == userId || request.auth.uid == friendId);
      }

      // Subcollection: friendRequests (incoming)
      match /friendRequests/{requesterId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null;
        allow delete, update: if request.auth != null &&
                                 (request.auth.uid == userId || request.auth.uid == requesterId);
      }

      // Subcollection: sentRequests (outgoing)
      match /sentRequests/{recipientId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow delete, update: if request.auth != null &&
                                 (request.auth.uid == userId || request.auth.uid == recipientId);
      }

      // Subcollection: joinedEvents
      match /joinedEvents/{eventId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create, delete: if request.auth != null && request.auth.uid == userId;
      }

      // Subcollection: invitations (event invitations received by user)
      match /invitations/{eventId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null;
        allow delete, update: if request.auth != null &&
                                 (request.auth.uid == userId ||
                                  request.auth.uid == resource.data.from);
      }

      // Subcollection: favoriteEvents
      match /favoriteEvents/{eventId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create, delete: if request.auth != null && request.auth.uid == userId;
      }

      // Subcollection: pinnedEvents
      match /pinnedEvents/{eventId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create, delete: if request.auth != null && request.auth.uid == userId;
      }

      // Subcollection: followedOrganizations
      match /followedOrganizations/{organizationId} {
        allow get, list: if request.auth != null && request.auth.uid == userId;
        allow create, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    
    // --- NOTIFICATIONS COLLECTION ---
    
    match /notifications/{notificationId} {
      // Allow read access only if the logged-in user owns the notification
      allow get, list: if request.auth != null && request.auth.uid == resource.data.userId;

      // Allow authenticated users to create notifications for any user (e.g., sending friend requests)
      allow create: if request.auth != null;

      // Allow updating/deleting only for the owner
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // --- STORIES COLLECTION ---
    
    match /stories/{storyId} {
      // Allow read if user has joined the event OR is friend with the story creator
      allow get, list: if request.auth != null &&
                        (hasJoinedEvent(resource.data.eventId) ||
                         isFriendOfStoryCreator(resource.data.userId));

      // Allow create if user has joined the event and userId matches authenticated user
      allow create: if request.auth != null &&
                     request.auth.uid == request.resource.data.userId &&
                     hasJoinedEvent(request.resource.data.eventId);

      // Allow delete only by story owner
      allow delete: if request.auth != null &&
                     request.auth.uid == resource.data.userId;

      // Prevent updates (stories are immutable once created)
      allow update: if false;
    }
  }
}
